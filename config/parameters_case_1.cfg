# IMPORTANT:
# For every key it is mandatory to specify the unit_type so the program can perform the necessary conversions:
# The unit is specified using the keyword unit_type: [type]. Use 'ignore' to don't perfrom any conversion.

simulation:
{
# Name to give to the output folder (every run will be automatically suffixed by a number)
# unit_type: [ignore]
basename    = "test1"

# Max error allowed from the exact solution (absolute)
# unit_type: [percentual]
error_abs = 0.00%

# Max error allowed from the exact solution (relative)  
# unit_type: [percentual]
error_rel = 0.01%

# Simulation duration
# unit_type: [time]
duration = 30 ps

# Distance from the laser center where the particle will interact with laser.
# It should be comparable with ρ₀
# unit_type: [length]
laser_influence_radius = 200 μm

# How much we must to progress every time unit when the particle is inside the laser field
# A good values should be laser_period / 1000
# unit_type: [time]
time_resolution_laser = 0.5 fs
# How much we must to progress every time unit when the particle is outside the laser field
# unit_type: [time]
time_resolution_free  = 100 ps

# Contains some common functions that can be used by other functions
#
# Example: define the gaussian function according:
# http://en.wikipedia.org/wiki/Gaussian_function
# unit_type: [ignore]
func_commons = "
function gaussian(x, a, b, c, d)
    return a * math.exp(- (x - b)^2 / (2*c^2))+d;
end
"

}


laser:
{
# Pulse duration
# unit_type: [time]
duration = 1ps

# Params to be used in the 'func_electric_fields' section.
# Important points:
# 1. These values will be injected in 'func_electric_fields' with this conversion: func_param_tau -> tau
# 2. It is possible to use measure units: they will be converted to SI units before injection
# 3. These settings are not hardcoded. You can add any setting you want (starting with func_param) and you will find it inside the function.
# 4. Only float values are accepted

# unit_type: [time]
func_param_tau          = 700 fs
# unit_type: [length]
func_param_rho_0        = 5.2 μm
# unit_type: [pure float]
func_param_s            = 2.0
# unit_type: [length]
func_param_lambda       = 520 nm
# unit_type: [pure float]
func_param_alpha        = 1
# unit_type: [electric_field]
func_param_E_m          = 1000 V/m

#
# Available variables
#   D:  pulse durations                     [s]
#   t:  current_time [-D/2, +D/2]           [s]
#
#   x:  position x                          [m]
#   y:  position y                          [m]
#   z:  position z                          [m]
#   
#   func_param_* (without the prefix func_param_) 
#   
# This function must return a 3 item array [Ex,Ey,Ez,Bx,By,Bz] with the first 3 values measured in [V/m] and the last 3 values measured in [T]
# 
# unit_type: [ignore_start]

func_fields = "

    -- The forumula used in this function can be found in this article:
    -- Dynamics of an electron driven by relativistically intense laser radiation
    -- [A. L. Galkin, V. V. Korobkin, M. Yu. Romanovsky, and O. B. Shiryaev]

    -- Defining constants
    c           = 299792458
    
    -- Calculation
    z_r         = math.pi * rho_0 ^ 2 / lambda
    rho         = rho_0 * math.sqrt(1 + z^2 / z_r^2)
    epsilon     = lambda / (2 * math.pi * rho_0)
    xi          = t - z / c
    
    phi         = 2 * math.pi * c * xi / lambda + math.atan(z/z_r) - z*(x^2 + y^2 + z^2) / (z_r * rho^2)
    phi_tilde   = phi * math.atan(z/z_r)
    
    E_0         = E_m * rho / rho_0 * math.exp( - (xi / tau)^s - (math.sqrt(x^2 + y^2) / rho)^2)
    
    pol_x       = math.sqrt(0.5 * (1 + alpha))
    pol_y       = math.sqrt(0.5 * (1 - alpha))
    
    
    
    E_x         =   E_0 * pol_x * math.cos(phi)
    E_y         = - E_0 * pol_y * math.sin(phi)
    E_z         = 2 * E_0 * epsilon/rho * (  pol_x * x * math.sin(phi_tilde) + pol_y * y * math.cos(phi_tilde))
    
    B_x         = - E_y / c
    B_y         =   E_x / c
    B_z         = 2 * E_0 * epsilon/rho * (- pol_x * y * math.sin(phi_tilde) + pol_y * x * math.cos(phi_tilde)) / c
    
    return E_x, E_y, E_z, B_x, B_y, B_z
"
# unit_type: [ignore_end]

}

particle:
{
# Particle mass
# unit_type: [mass]
rest_mass = 1 m_e

# Particle charge
# unit_type: [charge]
charge = 1 e

# The initial position and momentum are token relative a node. This attribute let you specify which node this must to be relative.
# unit_type: [pure int]
initial_reference_node = 0

# Initial position of the particle relative to the first node
# unit_type: [length]
initial_position_x =    0.0 mm
initial_position_y =    0.0 mm
initial_position_z =   -5.0 μm

## Alternatively it is possible to specify the position so:
## unit_type: [length]
#initial_position_module =   0.0 mm
## unit_type: [angle]
#initial_position_theta  =  -5.0 °
#initial_position_phi    =   0.0 °


# Initial momentum of the particle
# unit_type: [momentum]
initial_momentum_x      =     0.0   Nm/s
initial_momentum_y      =     0.0   Nm/s
initial_momentum_z      =     1.0   eV

## Alternatively it is possible to specify the momentum so:
#
## unit_type: [momentum]
#initial_momentum_module    =   0.0 Nm/s
## unit_type: [angle]
#initial_momentum_theta     =   0.0 °
#initial_momentum_phi       =   0.0 °
}


laboratory:
{

node_0:
{
# unit_type: [length]
position_x		= 0 m
position_y		= 0 m
position_z		= 0 m

# unit_type: [angle]
rotation_theta	= 0.0°
rotation_phi	= 0.0°
}
	
}


field_renders:
{

# Available variables in formula
#	field(t,x,y,z)							[function]
#		.e_x								[V/m]
#		.e_y								[V/m]
#		.e_z								[V/m]
#		.b_x								[A/m]
#		.b_y								[A/m]
#		.b_z								[A/m]
#
#   D:  pulse durations                     [s]
#   t:  current_time [-D/2, +D/2]           [s]
#
#   x:  position x                          [m]
#   y:  position y                          [m]
#   z:  position z                          [m]
#
#	dx: small difference in x axis			[m]
#	dy: small difference in y axis			[m]
#	dz: small difference in z axis			[m]
#	dt: small difference in t				[s]
#

eb_mod:
{
# unit_type: [ignore]
title_1="$|\vec{E}|$"
title_2="$|\vec{B}|$"
plane="xz"
# unit_type: [length]
axis_cut=0 mm
# unit_type: [length]
space_resolution = 0.5 μm
# unit_type: [length]
space_size_x = 100  μm
space_size_y = 100  μm
space_size_z = 1000 μm
# 
# unit_type: [time]
time_resolution = 1.5fs
 
# unit_type: [time]
movie_length = 5m

# unit_type: [ignore_start]
formula="
	f = field(t,x,y,z)
	return sqrt(f.e_x * f.e_x + f.e_y * f.e_y + f.e_z * f.e_z), sqrt(f.b_x * f.b_x + f.b_y * f.b_y + f.b_z * f.b_z)
"
# unit_type: [ignore_end]
}

eb_z:
{
# unit_type: [ignore]
title_1="$E_z$"
title_2="$B_z$"
plane="xy"
# unit_type: [length]
axis_cut=0 mm
# unit_type: [length]
space_resolution = 0.5 μm
# unit_type: [length]
space_size_x = 100  μm
space_size_y = 100  μm
space_size_z = 1000 μm
# unit_type: [time]
time_resolution = 1.5fs
 
# unit_type: [time]
movie_length = 5m

# unit_type: [ignore_start]
formula="
	f = field(t,x,y,z)
	return f.b_z, f.b_z
"
# unit_type: [ignore_end]
}


diff_xy:
{
# unit_type: [ignore]
title_1="$\frac{1}{c^{2}}\frac{\partial ^{2}\vec{E}_{x}}{\partial t^{2}}-\nabla^{2} \vec{E}_{x}$"
title_2="$\frac{1}{c^{2}}\frac{\partial ^{2}\vec{E}_{y}}{\partial t^{2}}-\nabla^{2} \vec{E}_{y}$"
title_3="$\frac{1}{c^{2}}\frac{\partial ^{2}\vec{E}_{z}}{\partial t^{2}}-\nabla^{2} \vec{E}_{z}$"
title_4="$\frac{1}{c^{2}}\frac{\partial ^{2}|\vec{E}|}{\partial t^{2}}-\nabla^{2} |\vec{E}|$"

plane="xy"
# unit_type: [length]
axis_cut=0 mm
# unit_type: [length]
space_resolution = 0.5 μm
# unit_type: [length]
space_size_x = 100  μm
space_size_y = 100  μm
space_size_z = 1000 μm
# unit_type: [time]
time_resolution = 1.5fs
 
# unit_type: [time]
movie_length = 5m

# unit_type: [ignore_start]
formula="

	c = 299792458
	
	f_0  = field(t,x,y,z)
	
	f_t1 = field(t+dt,x,y,z)
	f_t2 = field(t-dt,x,y,z)
	f_x1 = field(t,x+dx,y,z)
	f_x2 = field(t,x-dx,y,z)
	f_y1 = field(t,x,y+dy,z)
	f_y2 = field(t,x,y-dy,z)
	f_z1 = field(t,x,y,z+dz)
	f_z2 = field(t,x,y,z-dz)
	
	
	diff_e_x = 1 / (c*c) * (f_t1.e_x - 2 * f_0.e_x + f_t2.e_x) / (dt * dt) - (f_x1.e_x - 2 * f_0.e_x + f_x2.e_x) / (dx * dx)
	diff_e_y = 1 / (c*c) * (f_t1.e_y - 2 * f_0.e_y + f_t2.e_y) / (dt * dt) - (f_y1.e_y - 2 * f_0.e_y + f_y2.e_y) / (dy * dy)
	diff_e_z = 1 / (c*c) * (f_t1.e_z - 2 * f_0.e_z + f_t2.e_z) / (dt * dt) - (f_z1.e_z - 2 * f_0.e_z + f_z2.e_z) / (dz * dz)
	diff_b_x = 1 / (c*c) * (f_t1.b_x - 2 * f_0.b_x + f_t2.b_x) / (dt * dt) - (f_x1.b_x - 2 * f_0.b_x + f_x2.b_x) / (dx * dx)
	diff_b_y = 1 / (c*c) * (f_t1.b_y - 2 * f_0.b_y + f_t2.b_y) / (dt * dt) - (f_y1.b_y - 2 * f_0.b_y + f_y2.b_y) / (dy * dy)
	diff_b_z = 1 / (c*c) * (f_t1.b_z - 2 * f_0.b_z + f_t2.b_z) / (dt * dt) - (f_z1.b_z - 2 * f_0.b_z + f_z2.b_z) / (dz * dz)
	
	return e_x, e_y, e_z, b_x, b_y, b_z
"
# unit_type: [ignore_end]
}



}
