# IMPORTANT:
# For every key it is mandatory to specify the unit_type so the program can perform the necessary conversions:
# The unit is specified using the keyword unit_type: [type]. Use 'ignore' to don't perfrom any conversion.

simulation:
{
# Name to give to the output folder (every run will be automatically suffixed by a number)
# unit_type: [ignore]
basename    = "test1"

# Max error allowed from the exact solution (absolute)
# unit_type: [percentual]
error_abs = 0.00%

# Max error allowed from the exact solution (relative)  
# unit_type: [percentual]
error_rel = 0.01%

# Simulation duration
# unit_type: [time]
duration = 1 μs

# Distance from the laser center where the particle will interact with laser.
# It should be comparable with ρ₀
# unit_type: [length]
laser_influence_radius = 200 μm

# How much we must to progress every time unit when the particle is inside the laser field
# A good values should be laser_period / 1000
# unit_type: [time]
time_resolution_laser = 0.5 fs
# How much we must to progress every time unit when the particle is outside the laser field
# unit_type: [time]
time_resolution_free  = 100 ps

# How large must be big the laboratory map in pixels
#
# unit_type: [pure_int]
max_labmap_size = 1920

# Contains some common functions that can be used by other functions
#
# Example: define the gaussian function according:
# http://en.wikipedia.org/wiki/Gaussian_function
# unit_type: [ignore]
func_commons = "
function gaussian(x, a, b, c, d)
    return a * math.exp(- (x - b)^2 / (2*c^2))+d;
end
"

}


laser:
{
# Params to be used in the 'func_electric_fields' section.
# Important points:
# 1. These values will be injected in 'func_electric_fields' with this conversion: func_param_tau -> tau
# 2. It is possible to use measure units: they will be converted to SI units before injection
# 3. These settings are not hardcoded. You can add any setting you want (starting with func_param) and you will find it inside the function.
# 4. Only float values are accepted

# unit_type: [time]
func_param_tau          = 700 fs
# unit_type: [length]
func_param_rho_0        = 5.2 μm
# unit_type: [pure float]
func_param_s            = 2.0
# unit_type: [length]
func_param_lambda       = 520 nm
# unit_type: [pure float]
func_param_alpha        = 1.0
# unit_type: [electric_field]
func_param_E_m          = 1000 V/m

#
# Available variables
#   t:  current_time [centrered in 0]       [s]
#
#   x:  position x                          [m]
#   y:  position y                          [m]
#   z:  position z                          [m]
#   
#   func_param_* (without the prefix func_param_) 
#   
# This function must return a 3 item array [Ex,Ey,Ez,Bx,By,Bz] with the first 3 values measured in [V/m] and the last 3 values measured in [T]
# 
# unit_type: [ignore_start]

func_fields = "

    -- The forumula used in this function can be found in this article:
    -- Dynamics of an electron driven by relativistically intense laser radiation
    -- [A. L. Galkin, V. V. Korobkin, M. Yu. Romanovsky, and O. B. Shiryaev]

    -- Defining constants
    c           = 299792458
    
    -- Calculation
    z_r         = math.pi * rho_0 ^ 2 / lambda
    rho         = rho_0 * math.sqrt(1 + z^2 / z_r^2)
    epsilon     = lambda / (2 * math.pi * rho_0)
    xi          = t - z / c
    
    phi         = 2 * math.pi * c * xi / lambda + math.atan(z/z_r) - z*(x^2 + y^2 + z^2) / (z_r * rho^2)
    phi_tilde   = phi * math.atan(z/z_r)
    
    E_0         = E_m * rho / rho_0 * math.exp( - (xi / tau)^s - (math.sqrt(x^2 + y^2) / rho)^2)
    
    pol_x       = math.sqrt(0.5 * (1 + alpha))
    pol_y       = math.sqrt(0.5 * (1 - alpha))
    
    
    
    E_x         =   E_0 * pol_x * math.cos(phi)
    E_y         = - E_0 * pol_y * math.sin(phi)
    E_z         = 2 * E_0 * epsilon/rho * (  pol_x * x * math.sin(phi_tilde) + pol_y * y * math.cos(phi_tilde))
    
    B_x         = - E_y / c
    B_y         =   E_x / c
    B_z         = 2 * E_0 * epsilon/rho * (- pol_x * y * math.sin(phi_tilde) + pol_y * x * math.cos(phi_tilde)) / c
    
    return E_x, E_y, E_z, B_x, B_y, B_z
"
# unit_type: [ignore_end]

}

particle:
{
# Particle mass
# unit_type: [mass]
rest_mass = 1 m_e

# Particle charge
# unit_type: [charge]
charge = 1 e

# The initial position and momentum are token relative a node. This attribute let you specify which node this must to be relative.
# unit_type: [pure int]
initial_reference_node = 0

# Initial position of the particle relative to the first node
# unit_type: [length]
initial_position_x =    0.0 mm
initial_position_y =    0.0 mm
initial_position_z =   -5.0 μm

## Alternatively it is possible to specify the position so:
## unit_type: [length]
#initial_position_rho =   0.0 mm
## unit_type: [angle]
#initial_position_theta  =  -5.0 °
#initial_position_phi    =   0.0 °


# Initial momentum of the particle
# unit_type: [momentum]
#initial_momentum_x      =     0.0   Nm/s
#initial_momentum_y      =     0.0   Nm/s
#initial_momentum_z      =     0.0   Nm/s

## Alternatively it is possible to specify the momentum so:
#
## unit_type: [momentum]
#initial_momentum_rho    =   0.0 Nm/s
## unit_type: [angle]
#initial_momentum_theta     =   0.0 °
#initial_momentum_phi       =   0.0 °

# Another possibility is to define the momentum as energy. The program will take care of the conversion using relativistic formulas

# unit_type: [energy]
initial_energy_x      =     0.0   eV
initial_energy_y      =     0.0   eV
initial_energy_z      =     1.0   keV

## Alternatively it is possible to specify the momentum so:
#
## unit_type: [energy]
#initial_energy_rho    =   0.0 Nm/s
## unit_type: [angle]
#initial_energy_theta     =   0.0 °
#initial_energy_phi       =   0.0 °

}


laboratory:
{

node_0:
{
# unit_type: [length]
position_x      = 0 m
position_y      = 0 m
position_z      = 0 m

# unit_type: [angle]
rotation_theta  = 0.0°
rotation_phi    = 0.0°
}
    
}


field_renders:
{

# Available variables in formula
#   field(t,x,y,z)                          [function]
#       .e_x                                [V/m]
#       .e_y                                [V/m]
#       .e_z                                [V/m]
#       .b_x                                [A/m]
#       .b_y                                [A/m]
#       .b_z                                [A/m]
#
#   D:  pulse duration                      [s]
#   t:  current_time [-D/2, +D/2]           [s]
#
#   size_x:    render size x                [m]
#   size_y:    render size y                [m]
#   size_z:    render size z                [m]
#
#   x:  position x  [-size_x/2, +size_x/2]  [m]
#   y:  position y  [-size_y/2, +size_y/2]  [m]
#   z:  position z  [-size_z/2, +size_z/2]  [m]
#
#   dx: small difference in x axis          [m]
#   dy: small difference in y axis          [m]
#   dz: small difference in z axis          [m]
#   dt: small difference in t               [s]
#

eb_xz:
{
# unit_type: [ignore]
enabled=false

# unit_type: [ignore]
title_1="$E_x$"
title_2="$E_y$"
title_3="$E_z$"
title_4="$|E|$"
title_5="$B_x$"
title_6="$B_y$"
title_7="$B_z$"
title_8="$|B|$"
plane="xz"
# unit_type: [length]
axis_cut=0 mm
# unit_type: [length]
space_resolution = 30 μm
# unit_type: [length]
space_size_x = 20  μm
space_size_y = 20  μm
space_size_z = 100 μm
# unit_type: [time]
time_start		= -50 fs
time_end		=  50 fs
time_resolution = 0.1 fs

# Color to apply to z axis
# Define your colors in hex format separated by double dashes.
# These variables will be replaced:
#   min:	 minimum value
#   max:	 maximum value
#   min_abs: minimum abs value (it will be a value >= 0)
#   max_abs: maximum abs value (it will be a value >= 0)
#
# It is possible to define a global 'colors' to all the graph generated by this render or individual colors for every graph using 'color_1', 'color_2', etc.
#
# unit_type: [ignore]
color_1 = "#dd1c77(-max_abs)--#c994c7--#e7e1ef--#ffffff(0)--#deebf7--#9ecae1--#3182bd(max_abs)"
color_2 = "#dd1c77(-max_abs)--#c994c7--#e7e1ef--#ffffff(0)--#deebf7--#9ecae1--#3182bd(max_abs)"
color_3 = "#dd1c77(-max_abs)--#c994c7--#e7e1ef--#ffffff(0)--#deebf7--#9ecae1--#3182bd(max_abs)"
color_4 = "#dd1c77(-max_abs)--#c994c7--#e7e1ef--#ffffff(0)--#deebf7--#9ecae1--#3182bd(max_abs)"
color_5 = "#b2182b(-max_abs)--#ef8a62--#fddbc7--#ffffff(0)--#d1e5f0--#67a9cf--#2166ac(max_abs)"
color_6 = "#b2182b(-max_abs)--#ef8a62--#fddbc7--#ffffff(0)--#d1e5f0--#67a9cf--#2166ac(max_abs)"
color_7 = "#b2182b(-max_abs)--#ef8a62--#fddbc7--#ffffff(0)--#d1e5f0--#67a9cf--#2166ac(max_abs)"
color_8 = "#b2182b(-max_abs)--#ef8a62--#fddbc7--#ffffff(0)--#d1e5f0--#67a9cf--#2166ac(max_abs)"
 
# unit_type: [time]
movie_length = 5m

# unit_type: [ignore_start]
formula="
    f = field(t,x,y,z)
    return f.e_x, f.e_y, f.e_z, math.sqrt(f.e_x * f.e_x + f.e_y *  f.e_y + f.e_z * f.e_z), f.b_x, f.b_y, f.b_z, math.sqrt(f.b_x * f.b_x + f.b_y *  f.b_y + f.b_z * f.b_z)
"
# unit_type: [ignore_end]
}

eb_xy:
{
# unit_type: [ignore]
enabled=false

# unit_type: [ignore]
title_1="$E_x$"
title_2="$E_y$"
title_3="$E_z$"
title_4="$|E|$"
title_5="$B_x$"
title_6="$B_y$"
title_7="$B_z$"
title_8="$|B|$"
plane="xy"
# unit_type: [length]
axis_cut=0 mm
# unit_type: [length]
space_resolution = 30 nm
# unit_type: [length]
space_size_x = 20  μm
space_size_y = 20  μm
space_size_z = 100 μm
# unit_type: [time]
time_start		= -50 fs
time_end		=  50 fs
time_resolution = 0.1 fs

# Color to apply to z axis
# Define your colors in hex format separated by double dashes.
# These variables will be replaced:
#   min:	 minimum value
#   max:	 maximum value
#   min_abs: minimum abs value (it will be a value >= 0)
#   max_abs: maximum abs value (it will be a value >= 0)
#
# It is possible to define a global 'colors' to all the graph generated by this render or individual colors for every graph using 'color_1', 'color_2', etc.
#
# unit_type: [ignore]
color_1 = "#dd1c77(-max_abs)--#c994c7--#e7e1ef--#ffffff(0)--#deebf7--#9ecae1--#3182bd(max_abs)"
color_2 = "#dd1c77(-max_abs)--#c994c7--#e7e1ef--#ffffff(0)--#deebf7--#9ecae1--#3182bd(max_abs)"
color_3 = "#dd1c77(-max_abs)--#c994c7--#e7e1ef--#ffffff(0)--#deebf7--#9ecae1--#3182bd(max_abs)"
color_4 = "#dd1c77(-max_abs)--#c994c7--#e7e1ef--#ffffff(0)--#deebf7--#9ecae1--#3182bd(max_abs)"
color_5 = "#b2182b(-max_abs)--#ef8a62--#fddbc7--#ffffff(0)--#d1e5f0--#67a9cf--#2166ac(max_abs)"
color_6 = "#b2182b(-max_abs)--#ef8a62--#fddbc7--#ffffff(0)--#d1e5f0--#67a9cf--#2166ac(max_abs)"
color_7 = "#b2182b(-max_abs)--#ef8a62--#fddbc7--#ffffff(0)--#d1e5f0--#67a9cf--#2166ac(max_abs)"
color_8 = "#b2182b(-max_abs)--#ef8a62--#fddbc7--#ffffff(0)--#d1e5f0--#67a9cf--#2166ac(max_abs)"
 
# unit_type: [time]
movie_length = 5m

# unit_type: [ignore_start]
formula="
    f = field(t,x,y,z)
    return f.e_x, f.e_y, f.e_z, math.sqrt(f.e_x * f.e_x + f.e_y *  f.e_y + f.e_z * f.e_z), f.b_x, f.b_y, f.b_z, math.sqrt(f.b_x * f.b_x + f.b_y *  f.b_y + f.b_z * f.b_z)
"
# unit_type: [ignore_end]
}


diff_xy:
{
# unit_type: [ignore]
enabled=false

# unit_type: [ignore]
title_1="$\\frac{1}{c^{2}}\\frac{\\partial ^{2}\\vec{E}_{x}}{\\partial t^{2}}-\\nabla^{2} \\vec{E}_{x}$"
title_2="$\\frac{1}{c^{2}}\\frac{\\partial ^{2}\\vec{E}_{y}}{\\partial t^{2}}-\\nabla^{2} \\vec{E}_{y}$"
title_3="$\\frac{1}{c^{2}}\\frac{\\partial ^{2}\\vec{E}_{z}}{\\partial t^{2}}-\\nabla^{2} \\vec{E}_{z}$"
title_4="$\\frac{1}{c^{2}}\\frac{\\partial ^{2}\\vec{B}_{x}}{\\partial t^{2}}-\\nabla^{2} \\vec{B}_{x}$"
title_5="$\\frac{1}{c^{2}}\\frac{\\partial ^{2}\\vec{B}_{y}}{\\partial t^{2}}-\\nabla^{2} \\vec{B}_{y}$"
title_6="$\\frac{1}{c^{2}}\\frac{\\partial ^{2}\\vec{B}_{z}}{\\partial t^{2}}-\\nabla^{2} \\vec{B}_{z}$"

plane="xy"
# unit_type: [length]
axis_cut=0 mm
# unit_type: [length]
space_resolution = 30 nm
# unit_type: [length]
space_size_x = 20  μm
space_size_y = 20  μm
space_size_z = 100 μm
# unit_type: [time]
time_start		= -50 fs
time_end		=  50 fs
time_resolution = 0.1 fs

# Color to apply to z axis
# Define your colors in hex format separated by double dashes.
# These variables will be replaced:
#   min:	 minimum value
#   max:	 maximum value
#   min_abs: minimum abs value (it will be a value >= 0)
#   max_abs: maximum abs value (it will be a value >= 0)
#
# It is possible to define a global 'colors' to all the graph generated by this render or individual colors for every graph using 'color_1', 'color_2', etc.
#
# unit_type: [ignore]
color_1 = "#dd1c77(-max_abs)--#c994c7--#e7e1ef--#ffffff(0)--#deebf7--#9ecae1--#3182bd(max_abs)"
color_2 = "#dd1c77(-max_abs)--#c994c7--#e7e1ef--#ffffff(0)--#deebf7--#9ecae1--#3182bd(max_abs)"
color_3 = "#dd1c77(-max_abs)--#c994c7--#e7e1ef--#ffffff(0)--#deebf7--#9ecae1--#3182bd(max_abs)"
color_4 = "#b2182b(-max_abs)--#ef8a62--#fddbc7--#ffffff(0)--#d1e5f0--#67a9cf--#2166ac(max_abs)"
color_5 = "#b2182b(-max_abs)--#ef8a62--#fddbc7--#ffffff(0)--#d1e5f0--#67a9cf--#2166ac(max_abs)"
color_6 = "#b2182b(-max_abs)--#ef8a62--#fddbc7--#ffffff(0)--#d1e5f0--#67a9cf--#2166ac(max_abs)"
# unit_type: [time]
movie_length = 5m

# unit_type: [ignore_start]
formula="

    c = 299792458
    
    f_0  = field(t,x,y,z)
    
    f_t1 = field(t+dt,x,y,z)
    f_t2 = field(t-dt,x,y,z)
    f_x1 = field(t,x+dx,y,z)
    f_x2 = field(t,x-dx,y,z)
    f_y1 = field(t,x,y+dy,z)
    f_y2 = field(t,x,y-dy,z)
    f_z1 = field(t,x,y,z+dz)
    f_z2 = field(t,x,y,z-dz)
    
    diff_e_x = 1 / (c*c) * (f_t1.e_x - 2 * f_0.e_x + f_t2.e_x) / (dt * dt) - (f_x1.e_x - 2 * f_0.e_x + f_x2.e_x) / (dx * dx)
    diff_e_y = 1 / (c*c) * (f_t1.e_y - 2 * f_0.e_y + f_t2.e_y) / (dt * dt) - (f_y1.e_y - 2 * f_0.e_y + f_y2.e_y) / (dy * dy)
    diff_e_z = 1 / (c*c) * (f_t1.e_z - 2 * f_0.e_z + f_t2.e_z) / (dt * dt) - (f_z1.e_z - 2 * f_0.e_z + f_z2.e_z) / (dz * dz)
    diff_b_x = 1 / (c*c) * (f_t1.b_x - 2 * f_0.b_x + f_t2.b_x) / (dt * dt) - (f_x1.b_x - 2 * f_0.b_x + f_x2.b_x) / (dx * dx)
    diff_b_y = 1 / (c*c) * (f_t1.b_y - 2 * f_0.b_y + f_t2.b_y) / (dt * dt) - (f_y1.b_y - 2 * f_0.b_y + f_y2.b_y) / (dy * dy)
    diff_b_z = 1 / (c*c) * (f_t1.b_z - 2 * f_0.b_z + f_t2.b_z) / (dt * dt) - (f_z1.b_z - 2 * f_0.b_z + f_z2.b_z) / (dz * dz)
    
    return diff_e_x, diff_e_y, diff_e_z, diff_b_x, diff_b_y, diff_b_z
"
# unit_type: [ignore_end]
}
}
# This section contains the analysis about the system response under different parameter values.
# It compute the final particle attributes under different initial conditions and plot it in a graph.
#
# The format for any analisis is:
# 	analyze particle <attribute_out_1>, <attribute_out_2>, ... when <object_in> <attribute_in> lineally changes by <variation> in <steps> steps
# 	analyze particle <attribute_out_1>, <attribute_out_2>, ... when <object_in> <attribute_in> randomly changes by <variation> in <steps> steps
#
# Where:
#	<attribute_out> is a particle attribute:
#		position_x, position_y, position_z, position_phi, position_theta, position_rho
#		momentum_x, momentum_y, momentum_z, momentum_phi, momentum_theta, position_rho
#		energy
#
#	<object_in> is the type of attribute we want to modify:
#		particle, laser
#
#
#	<attribute_in> is a particle or laser attribute:
#
#		For particle:
#			rest_mass, charge
#			initial_position_x, initial_position_y, initial_position_z, initial_position_rho, initial_position_theta, initial_position_phi
#			initial_momentum_x, initial_momentum_y, initial_momentum_z, initial_momentum_rho, initial_momentum_theta, initial_momentum_phi
#		For laser:
#			[all params who starts with 'func_param_*' written without the prefix]
#
#	<variation> is how much we must to cheange the value and can have one of these two formats:
#			<value>%	Value in percentual of existing attribute_in
#			<value>		Value in absolute in SI of existing attribute_in
#
# All value here must be specified in SI international system
response_analyses:
{
# unit_type: [ignore]
analysis_1 = "analyze particle position_x, position_y, position_z         when particle position_x linearly changes by 1E-6 in 2000 steps"
analysis_2 = "analyze particle momentum_rho, momentum_phi, momentum_theta when particle momentum_rho linearly changes by 20% in 2000 steps"
analysis_3 = "analyze particle momentum_rho, momentum_phi, momentum_theta when laser E_m linearly changes by 60% in 2000 steps"
}



