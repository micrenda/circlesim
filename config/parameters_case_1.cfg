# IMPORTANT:
# For every key it is mandatory to specify the unit_type so the program can perform the necessary conversions:
# The unit is specified using the keyword unit_type: [type]. Use 'ignore' to don't perfrom any conversion.

simulation:
{
# Name to give to the output folder (every run will be automatically suffixed by a number)
# unit_type: [ignore]
basename    = "test1"

# Max error allowed from the exact solution (absolute)
# unit_type: [percentual]
error_abs = 0.00%

# Max error allowed from the exact solution (relative)  
# unit_type: [percentual]
error_rel = 0.01%

# Simulation duration
# unit_type: [time]
duration = 30 ps

# Distance from the laser center where the particle will interact with laser.
# It should be comparable with œÅ‚ÇÄ
# unit_type: [length]
laser_influence_radius = 200 Œºm

# How much we must to progress every time unit when the particle is inside the laser field
# A good values should be laser_period / 1000
# unit_type: [time]
time_resolution_laser = 0.5 fs
# How much we must to progress every time unit when the particle is outside the laser field
# unit_type: [time]
time_resolution_free  = 100 ps

# Contains some common functions that can be used by other functions
#
# Example: define the gaussian function according:
# http://en.wikipedia.org/wiki/Gaussian_function
# unit_type: [ignore]
func_commons = "
function gaussian(x, a, b, c, d)
    return a * math.exp(- (x - b)^2 / (2*c^2))+d;
end
"

}


laser:
{
# Pulse duration
# unit_type: [time]
duration = 1ps

# Params to be used in the 'func_electric_fields' section.
# Important points:
# 1. These values will be injected in 'func_electric_fields' with this conversion: func_param_tau -> tau
# 2. It is possible to use measure units: they will be converted to SI units before injection
# 3. These settings are not hardcoded. You can add any setting you want (starting with func_param) and you will find it inside the function.
# 4. Only float values are accepted

# unit_type: [time]
func_param_tau          = 700 fs
# unit_type: [length]
func_param_rho_0        = 5.2 Œºm
# unit_type: [pure float]
func_param_s            = 2.0
# unit_type: [length]
func_param_lambda       = 520 nm
# unit_type: [pure float]
func_param_alpha        = 1
# unit_type: [electric_field]
func_param_E_m          = 1000 V/m

#
# Available variables
#   D:  pulse durations                     [s]
#   t:  current_time [-D/2, +D/2]           [s]
#
#   x:  position x                          [m]
#   y:  position y                          [m]
#   z:  position z                          [m]
#   
#   func_param_* (without the prefix func_param_) 
#   
# This function must return a 3 item array [Ex,Ey,Ez,Bx,By,Bz] with the first 3 values measured in [V/m] and the last 3 values measured in [T]
# 
# unit_type: [ignore_start]

func_fields = "

    -- The forumula used in this function can be found in this article:
    -- Dynamics of an electron driven by relativistically intense laser radiation
    -- [A. L. Galkin, V. V. Korobkin, M. Yu. Romanovsky, and O. B. Shiryaev]

    -- Defining constants
    c           = 299792458
    
    -- Calculation
    z_r         = math.pi * rho_0 ^ 2 / lambda
    rho         = rho_0 * math.sqrt(1 + z^2 / z_r^2)
    epsilon     = lambda / (2 * math.pi * rho_0)
    xi          = t - z / c
    
    phi         = 2 * math.pi * c * xi / lambda + math.atan(z/z_r) - z*(x^2 + y^2 + z^2) / (z_r * rho^2)
    phi_tilde   = phi * math.atan(z/z_r)
    
    E_0         = E_m * rho / rho_0 * math.exp( - (xi / tau)^s - (math.sqrt(x^2 + y^2) / rho)^2)
    
    pol_x       = math.sqrt(0.5 * (1 + alpha))
    pol_y       = math.sqrt(0.5 * (1 - alpha))
    
    
    
    E_x         =   E_0 * pol_x * math.cos(phi)
    E_y         = - E_0 * pol_y * math.sin(phi)
    E_z         = 2 * E_0 * epsilon/rho * (  pol_x * x * math.sin(phi_tilde) + pol_y * y * math.cos(phi_tilde))
    
    B_x         = - E_y / c
    B_y         =   E_x / c
    B_z         = 2 * E_0 * epsilon/rho * (- pol_x * y * math.sin(phi_tilde) + pol_y * x * math.cos(phi_tilde)) / c
    
    return E_x, E_y, E_z, B_x, B_y, B_z
"
# unit_type: [ignore_end]

}

particle:
{
# Particle mass
# unit_type: [mass]
rest_mass = 1 m_e

# Particle charge
# unit_type: [charge]
charge = 1 e

# The initial position and momentum are token relative a node. This attribute let you specify which node this must to be relative.
# unit_type: [pure int]
initial_reference_node = 0

# Initial position of the particle relative to the first node
# unit_type: [length]
initial_position_x =    0.0 mm
initial_position_y =    0.0 mm
initial_position_z =   -5.0 Œºm

## Alternatively it is possible to specify the position so:
## unit_type: [length]
#initial_position_module =   0.0 mm
## unit_type: [angle]
#initial_position_theta  =  -5.0 ¬∞
#initial_position_phi    =   0.0 ¬∞


# Initial momentum of the particle
# unit_type: [momentum]
initial_momentum_x      =     0.0   Nm/s
initial_momentum_y      =     0.0   Nm/s
initial_momentum_z      =     1.0   eV

## Alternatively it is possible to specify the momentum so:
#
## unit_type: [momentum]
#initial_momentum_module    =   0.0 Nm/s
## unit_type: [angle]
#initial_momentum_theta     =   0.0 ¬∞
#initial_momentum_phi       =   0.0 ¬∞
}

accellerator:
{
# Nodes number
# unit_type: [pure int]
nodes = 5

# Radius
# unit_type: [length]
radius = 10 km


# Specify how the first node (node 0) axis must be placed respect to the laboratory axis.
# The laser pulse will have the E and B in the xy plane and will propagate on z axis.
# The laboratory nodes will have their nodes placed in xy plane (with z=0) and the first node (node 0) will
# be located at position x=0, y=radius
#
# MODE_P        The x,y,z axis will be aligned to the laboratory axis. The laser will propagate in a direction perpendicular
#               the accellerator plane. (x=+x·µ£, y=+y·µ£, z=+z·µ£)
#
# MODE_T_FW     The z axis will be tangent to the accellerator radius (clockwise).
#               The x and y node axis will be respectively aligned to the lab y and z axis. (x=+y·µ£, y=+z·µ£, z=+x·µ£)
#
# MODE_T_BW     The z axis will be tangent to the accellerator radius (counter-clockwise).
#               The x and y node axis will be respectively aligned to the lab y and z axis. (x=-y·µ£, y=z·µ£, z=-x·µ£)
# unit_type: [ignore]
node_axis_mode="MODE_T_FW"

# Specify how to rotate the axis if every node. The first node (node 0) will have no rotation, while the other nodes will be rotated by 2ùúã  * i / n (where i is the node index increasing clockwise and n is the number of nodes)
# unit_type: [ignore]
node_axis_rotate_theta  = true
node_axis_rotate_phi    = true

# Specify how must to syncronize the laser pulse with position of the particle
# The pulse is located in the origin. The timing allow to specify in which moment of the pulse we should be
# Allowed values: TURN_ON, CONSTANT, TURN_OFF
# unit_type: [ignore]
timing_mode="CONSTANT"
# This value allow us to specify the exact position. It must be between 0 and 1. If mode = CONSTANT, and value = 0, the electron will be at origin when the laser start the constant phase.
# If value = 1 the the electron will be at origin at the end of the constant phase. If value = 0.5 it will be in the center of the constant phase.
# unit_type: [percentual]
timing_value=50%
}


output:
{
# These setting control the generation of field map plotting: it generates a text files containing for every plane (xy,xz,yz) the value of the field.
# Because these files may become quite large (several GB's) it is possible to selectively enable/disable them and set its resolution.
#   
# unit_type: [ignore]
field_map_enable_xy = false 
field_map_enable_xz = false
field_map_enable_yz = true

# Set the time and space resolution:
#  time  resolution: how often the field status must be calculated (the calulation starts when the electron enter into the laser influence radius and ends when the electron exit this radius)
#  space resolution: how many point in space must be calculated for every time frame (the points are token equally distribuited in range -influence_radius, +influence_radius).
# The total number of points can be calculated so:
#  points_count = (time_exit - time_enter) / time_res * (2 * influence_radius / space_res)¬≤
#
# To have an idea, to have the same file size:
#  if you double the time you have to double the resolution time
#  if you double the laser_influence_radius you have to increase around 16 times the resolution space
#
# unit_type: [time]
field_map_resolution_time  = 40 fs
# unit_type: [length]
field_map_resolution_space = 4 Œºm

}
